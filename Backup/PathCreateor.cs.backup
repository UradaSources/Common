using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;

// 该平滑函数的原理
// 假设有6个路径点
// 0 -> 1 -> 2 -> 3 -> 4 -> 5
// 在路径点之间根据factor函数
// 在它们之间两两插入新点, 该点是根据factor计算的
// 0 -(next - (next-cur) * factor)-> 1
// 0称之为cur, 1称之为next, 新点称之为insert
// 再使用贝塞尔采样, 以next为控制点, cur和insert为端点
// 最后输出平滑后的点值
public class PathCreateor : MonoBehaviour
{
	public PointPath target;

	public List<Transform> controlPoint;
	
	public Vector3[] pathPoint;
	public bool closed = false;

	[SerializeField, Range(0, 1)]
	private float m_frontInsterFactor = 0.1f;
	[SerializeField, Range(0, 1)]
	private float m_backInsterFactor = 0.9f;

	public int curveSample = 4;

	// 将路径点保存为局部坐标
	// public bool local = false;

	public bool showPathControlPoint;
	public bool showPathPoint;

	public float FrontInsterFactor
	{
		get => m_frontInsterFactor;
		set
		{
			var max = 1 - m_backInsterFactor;
			m_frontInsterFactor = Mathf.Clamp(value, 0, max);
		}
	}
	public float BackInsterFactor
	{
		get => m_backInsterFactor;
		set
		{
			var max = 1 - m_frontInsterFactor;
			m_backInsterFactor = Mathf.Clamp(value, 0, max);
		}
	}

	[ContextMenu("Gen path point")]
	public void GenPathPoint()
	{
		if (controlPoint.Count <= 2)
		{
			this.pathPoint = null;
			return;
		}

		var points = new List<Vector3>();
		points.Add(controlPoint[0].position);

		for (int i = 1; i < controlPoint.Count - 1; i++)
		{
			var cur = controlPoint[i].position;

			// 根据预览计算插入点
			var last = controlPoint[i - 1].position;
			var ins1 = cur - m_frontInsterFactor * (cur - last);

			var next = controlPoint[i + 1].position;
			var ins2 = next - (1.0f - m_backInsterFactor) * (next - cur);

			// 计算采样数
			//var len = MathUtility.ApproximateLength((float t) => MathUtility.BezierCurve(ins1, cur, ins2, t), 24);
			//int sample = Mathf.Max(1, Mathf.FloorToInt(len * unitSample));

			for (int j = 0; j < curveSample; j++)
			{
				float t = ((float)j) / (curveSample - 1);
				var tmp = MathUtility.BezierCurve(ins1, cur, ins2, t);

				// 拐角曲线的采样点
				points.Add(tmp);
			}
		}

		// 添加未尾点
		points.Add(controlPoint[controlPoint.Count - 1].position);

		//if (!this.local)
		//{
		//	for (var k = 0; k < points.Count; k++)
		//		points[k] = this.transform.InverseTransformPoint(points[k]);
		//}

		pathPoint = points.ToArray();
	}

	[ContextMenu("Export path point")]
	public void ExportPathPoint()
	{
		var path = EditorUtility.SaveFilePanelInProject("Export path point", "pathData", "assets", "");
		if (!string.IsNullOrEmpty(path))
		{
			var res = ScriptableObject.CreateInstance<PointPath>();
			this.target = res;

			this.target.points = this.pathPoint;
			this.target.closed = this.closed;

			AssetDatabase.CreateAsset(res, path);
			EditorUtility.SetDirty(res);
		}
	}

	[ContextMenu("Write target")]
	public void WriteTarget()
	{
		this.target.points = this.pathPoint;
		this.target.closed = this.closed;

		EditorUtility.SetDirty(this.target);
	}

	[ContextMenu("Load target")]
	private void LoadTarget()
	{
		this.pathPoint = this.target.points;
		this.closed = this.target.closed;
	}

	private void OnDrawGizmos()
	{
		var trs = new Vector3[controlPoint.Count];

		int i = 0;
		foreach (var tr in controlPoint)
			trs[i++] = tr.position;

		if (showPathControlPoint) DebugUtility.DrawLines(this.closed, 0, Color.gray, trs);

		if (showPathPoint && this.pathPoint != null)
			DebugUtility.DrawLines(this.closed, 0, Color.green, this.pathPoint);
	}

	private void OnValidate()
	{
		this.FrontInsterFactor = m_frontInsterFactor;
		this.BackInsterFactor = m_backInsterFactor;
	}
}
